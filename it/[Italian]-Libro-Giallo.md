Ethereum ‚Äì un registro di transazioni decentralizzato generalizzato sicuro


Abstract. Il paradigma della blockchain, quando innestato a transazioni crittograficamente sicure ha dimostrato la sua utilit√† in numerosi progetti, non ultima Bitcoin. Tali progetti possono essere visualizzati come una semplice applicazione all‚Äôinterno di una risorsa digitale decentralizzata ma unica. Tale paradigma pu√≤ essere definito come macchina transazionale unica a stato condiviso.
Ethereum implementa questo paradigma in maniera generalizzata. Inoltre, fornisce una pluralit√† di risorse simili, ognuna delle quali con uno stato ed un codice operativo distinto ma capace di interagire attraverso una struttura di trasmissione di messaggi con ognuna delle altre risorse. Discutiamo qui il suo sviluppo, i problemi di implementazione, le opportunit√† che fornisce ed alcuni possibili ostacoli futuri.

1	Introduzione
La disponibilit√† massiccia di connessioni internet nella maggior parte del pianeta ha permesso alla trasmissione globale di informazioni di diventare incredibilmente conveniente. Le iniziative radicate nella tecnologia ‚Äì come Bitcoin ‚Äì hanno dimostrato, attraverso la potenza di ‚Äúmeccanismi del consenso‚Äù e del rispetto volontario del contratto sociale, che √® possibile utilizzare la rete per creare un sistema di trasferimento di valore decentralizzato, condiviso liberamente in tutto il mondo e virtualmente gratuito. 
Tale sistema pu√≤ considerarsi una versione molto specializzata di un meccanismo crittografico sicuro, basato sulle transazioni. Sistemi successivi quali Namecoin hanno adottato questa ‚Äúapplicazione valutaria‚Äù della tecnologia all‚Äôinterno di altre applicazioni, sebbene alquanto semplici.
Ethereum costituisce un progetto che tenta di costruire la versione generalizzata di tale tecnologia; ossia una tecnologia su cui qualsiasi idea, applicata al meccanismo basato sulle transazioni di stato, possa essere sviluppata. Inoltre esso mira a fornire allo sviluppatore un sistema end-to-end strettamente integrato per la creazione di software secondo un paradigma di computazione fino ad ora sconosciuto alla maggioranza: un sistema di computazione object messaging affidabile.

I.I Fattori Chiave. Gli obiettivi di questo progetto sono molteplici; un obiettivo chiave √® di facilitare le transazioni tra individui consenzienti che non avrebbero altrimenti mezzi per garantire reciproca fiducia. Ci√≤ potrebbe essere dovuto alla distanza geografica, a difficolt√† di interfacciamento, o ad incompatibilit√†, incompetenza, indisponibilit√†, spese, incertezza, non convenienza o difetto dei sistemi legali esistenti. Nel momento in cui sar√† specificato un sistema di cambiamento di stato attraverso un linguaggio di sviluppo ricco e privo di ambiguit√†, e predisposta una architettura con caratteristiche tali che sia ragionevole attendersi che un accordo tra due parti sar√† di per s√© in grado di costringere le parti a rispettarne i termini, tutti gli strumenti utili allo scopo saranno disponibili.
Gli accordi nel sistema proposto avrebbero diverse caratteristiche non necessariamente presenti nel mondo reale. Ad esempio, l‚Äôincorruttibilit√† di giudizio, spesso difficile da trovare, sarebbe naturalmente ottenuta tramite un interprete algoritmico. La trasparenza, ossia la possibilit√† di constatare esattamente, attraverso il transaction log, le regole o il codice informativo, le modalit√† con cui uno stato o un giudizio siano pervenuti, non √® riscontrata mai nelle societ√† umane, dal momento che il linguaggio naturale √® per sua natura vago, le informazioni sono spesso incomplete ed i pregiudizi sono difficili da eliminare.
In complesso, desidero fornire un sistema tale che gli utenti possano essere sicuri del risultato finale, a prescindere dal soggetto, sistema od organizzazione con cui interagiscono, e di come a tale risultato si sia pervenuti.

I.II Lavori precedenti. Fu Buterin [2013] a proporre per primo i concetti fondamentali del presente lavoro, nel tardo novembre del 2013. Nonostante questo si sia evoluto in molteplici maniere, il concetto chiave della blockchain, accompagnata da un linguaggio Turing-completo ed uno spazio di archiviazione inter-transazione praticamente illimitato, rimane immutata. Il sistema Hashcash introdotto da Back [2002] (in una retrospettiva quinquennale), costitu√¨ il primo impianto per l‚Äôimpiego di un sistema che richiedesse una prova dell‚Äôimpiego di risorse computazionali tramite decifrazione crittografica (proof of work), quale mezzo per la trasmissione di un segnale di valore in Internet. Nonostante esso non fu mai adottato su ampia scala, il lavoro fu poi riciclato ed espanso da Nakamoto [2008] per concepire un meccanismo crittograficamente sicuro per approdare ad un consenso generalizzato decentralizzato sull‚Äôordine ed il contenuto di una serie di transazioni finanziarie a firma digitale crittografica. Dai frutti di questo progetto, Bitcoin, √® derivata una prima impressione di un registro di transazioni decentralizzato.

Altri progetti furono poi costruiti sul successo di Bitcoin; le alt-coins introdussero numerose altre valute attraverso l‚Äôalterazione del protocollo. Alcune delle pi√π famose sono Litecoin e Primecoin, discusse da Sprankel [2013]. Altri progetti hanno puntato a sfruttare il meccanismo dietro ai core values del protocollo e riproporli; Aron [2012] discute, ad esempio, il progetto Namecoin che mira a creare un sistema di name-resolution [http://en.wikipedia.org/wiki/Name_resolution] decentralizzato. 
Ulteriori progetti puntano sullo sviluppo del network Bitcoin stesso, facendo leva sulle ingenti somme che interessano il sistema e l‚Äôaltrettanto vasta potenza di calcolo necessaria per il ‚Äúmeccanismo di consenso‚Äù. Il progetto Mastercoin, proposto da Willett [2013], mira a costruire un protocollo arricchito, rispetto alla base di quello Bitcoin, usando parti ausiliarie e aggiungendo numerose funzionalit√† di alto livello. Il progetto Coloured Coins, promosso da Rosenfeld [2012], adotta una strategia simile ma pi√π semplice, fregiando le regole di una transazione con l‚Äôobiettivo di rompere la fungibilit√† della valuta di base delle Bitcoin, e consentendo la creazione ed il tracciamento di token (gettoni) con l‚Äôuso di uno speciale software detto ‚Äúchroma-wallet‚Äù coerente con il protocollo.
Ulteriori lavori sono stati portati a termine in questo campo, scartando i principi della decentralizzazione; Ripple, discusso da Boutellier e Heinzen [2014], ha tentato di creare un sistema ‚Äúfederato‚Äù per lo scambio di valuta, dando vita ad un nuovo tipo di camera di compensazione finanziaria. Questa ha dimostrato che possono essere conseguiti grandi guadagni di efficienza mettendo da parte la premessa della decentralizzazione.
Lavori seminali sugli ‚Äúsmart contracts‚Äù sono stati effettuati da Szabo [1997] e Miller [1997]. Fu negli anni Novanta che divenne chiaro che l‚Äôadempimento forzoso di un contratto tramite algoritmi sarebbe potuto divenire un punto di forza per il progresso della cooperazione umana. Sebbene non furono avanzate proposte in tal senso, venne evidenziata la concreta possibilit√† che gli algoritmi avrebbero influenzato l‚Äôevoluzione delle leggi future. Alla luce di ci√≤, Ethereum pu√≤ essere considerato come un impianto generale di un sistema critto-legislativo.

2	Il Paradigma Blockchain

Ethereum, preso nel suo insieme, pu√≤ essere visto come una macchina basata sulle transazioni di stato: a partire da uno stato iniziale, si eseguono in maniera incrementale delle transazioni in grado di trasformarlo in un certo stato finale. Questo stato finale verr√† dunque accettato quale versione canonica del mondo di Ethereum. Lo stato pu√≤ includere informazioni che riguardano il saldo di un conto corrente, la reputazione, accordi, dati concernenti informazioni legate al mondo fisico; in breve, qualsiasi cosa che possa essere rappresentata da un computer √® ammissibile. Ergo, le transazioni rappresentano un arco valido tra due stati; l‚Äôaspetto della ‚Äúvalidit√†‚Äù √® cruciale ‚Äì il numero dei cambiamenti di stato non validi √® molto maggiore rispetto a quelli validi. I cambiamenti di stato non validi potrebbero, a.e. essere oggetti come la riduzione di un conto corrente in assenza di un corrispettivo accrescimento altrove. Un cambiamento di stato, per essere ritenuto valido, deve derivare da una transazione. Formalmente
(1)œÉ_(t+1)‚â°œí(œÉ_t,T)

Dove œí √® la funzione del cambiamento di stato. In Ethereum, œí, assieme a œÉ, sono considerevolmente pi√π potenti di qualsiasi sistema comparabile; œí consente ai componenti di svolgere una computazione arbitraria, mentre œÉ √® il parametro che permette ai componenti di immagazzinare uno stato arbitrario tra una transazione e un‚Äôaltra.
Le transazioni sono raccolte e riordinate in  blocchi; i blocchi a loro volta sono concatenati usando un hash crittografico che agisce come mezzo di riferimento. Un blocco funziona come un libro mastro, che registra una serie di transazioni, collegandole a quelle del blocco precedente e pone un identificatore per lo stato finale (non lo immagazzina, in quanto sarebbe troppo grande). Inoltre, danno rilevanza alle serie di transazioni concedendo incentivi ai nodi da decifrare (mining). Questa incentivazione ha luogo come funzione di transizione di stato, garantendo un premio sul conto del ‚Äúminatore‚Äù.
Il mining √® quel processo che fornisce supporto alla decifrazione di una serie di transazioni (un blocco) attraverso l‚Äôimpiego di uno sforzo computazionale, e che porta a compimento il processo prima di qualsiasi altro blocco concorrente. Si ottiene grazie ad una prova crittograficamente sicura. Questo schema √® noto come proof-of-work, ed √® discusso in dettaglio nella sezione 11.5. 
Formalmente, espandiamo a 
(2)
(3)
(4)
Dove Œ© √® la funzione di finalizzazione del blocco di transizione di stato (una funzione che premia un candidato); B √® il blocco in questione, che assieme ad altri componenti, include una serie di transazioni; infine Œ† √® la funzione di transizione di stato a livello del singolo blocco.
Questa √® la base del paradigma blockchain, un modello che costituisce la spina dorsale non solo di Ethereum, ma di tutti i sistemi basati sul consenso decentralizzato ad oggi esistenti.

II.I Valore. Affinch√© cenga incentivata la computazione all‚Äôinterno del network, √® necessario convergere ad un accordo sul metodo per la trasmissione di valore. Per affrontare questo tema, Ethereum ha una sua valuta intrinseca, Ether, conosciuta anche come ETH e a volte nominata con il simbolo ƒê (dall‚ÄôInglese antico). Il pi√π piccolo sottomultiplo di Ether, e di conseguenza quello su cui tutti gli interi della valuta sono conteggiati, √® il Wei. Un Ether corrisponde a 10^18 Wei. Esistono inoltre altri sottomultipli di Ether:

Nel presente lavoro, qualsiasi riferimento al valore nel contesto degli Ether, valuta, bilancio o pagamento, sar√† considerata in Wei.

II.II Quale Storia? Essendo il sistema decentralizzato ed avendo tutte le parti una opportunit√† di creare un nuovo blocco in coda ad una catena di blocchi preesistente, la struttura risultante sar√† necessariamente quella di un albero di blocchi. Affinch√© venga formato un consenso riguardo il sentiero di sviluppo di questo albero, dalla radice (il blocco iniziale) alla foglia (il blocco contenente le transazioni pi√π recenti), deve esistere uno schema su cui converga l‚Äôaccordo degli utenti. Nel caso in cui emerga una discrepanza tra due nodi sul sentiero radice-foglia pi√π corretto per la blockchain, viene a crearsi un bivio. Da questo deriva, in un certo punto nel tempo (corrispondente ad un blocco), la possibile coesistenza di pi√π stati del sistema: in questa situazione alcuni nodi riterrebbero ‚Äúcanonico‚Äù un certo blocco di transazioni, mentre altri giudicherebbero valido un altro blocco, che potrebbe potenzialmente contenere transazioni radicalmente differenti e/o incompatibili. Una situazione del genere deve essere evitata a tutti i costi in quanto l‚Äôincertezza che ne deriverebbe minerebbe alle fondamenta la fiducia nell‚Äôintero sistema.
Lo schema che utilizziamo per la generazione del consenso √® una versione semplificata del protocollo GHOST introdotto da Sompolinsky e Zohar [2013]. Questo processo √® dettagliato nella sezione 10.

3	Convenzioni
 
Per la notazione formale di questo lavoro, uso una serie di convenzioni tipografiche, alcune delle quali alquanto particolari:
I due insiemi di valori di stato altamente strutturati, ‚Äòtop-level‚Äô, sono indicati da lettere greche minuscole in grassetto. L‚Äôinsieme che ricade in uno stato del mondo √® dato da œÉ (o sue varianti), mentre quello compreso negli stati-macchina da Œº.
Le funzioni che operano su valori altamente strutturati sono denotate con una lettera greca maiuscola, come ad esempio la funzione di transizione di stato œí.
Per la maggior parte delle funzioni, viene utilizzata una lettera maiuscola, ad es. C, la funzione generale di costo. Eventuali pedici denoteranno varianti specializzate, ad es. CSSTORE, la funzione di costo legata all‚Äôoperazione SSTORE. Per funzioni specifiche, eventualmente definite esternamente, la formattazione del testo assume un effetto ‚Äúmacchina da scrivere‚Äù, ad esempio la hash function Keccak-256 (codifica vincente della competizione SHA-3) √® denotata come KEC (e generalmente segnalata semplicemente come Keccak).
Alle tuple [http://it.wikipedia.org/wiki/Tupla] ci si riferisce tipicamente con lettere maiuscole, ad esempio T, che √® utilizzata per denotare una transazione Ethereum. Quando specificato, per componenti individuali, possono essere aggiunti pedici, come Tn, indicante l‚Äôattributo nonce [http://it.wikipedia.org/wiki/Nonce] della suddetta transazione. La forma pedice, a sua volta, viene utilizzata per denotare il tipo; ad esempio, pedici in lettera maiuscola si riferiscono a tuple con attributi subscriptable [http://stackoverflow.com/questions/216972/in-python-what-does-it-mean-if-an-object-is-subscriptable-or-not].
Le sequenze scalari e a dimensione fissa (anche dette array o vettori), sono denotate con lettere dell‚Äôalfabeto minuscole, ad esempio n viene utilizzata per riferirsi alla transazione nonce. Per gli array con significati speciali, utilizzeremo le greche, ad es. Œ¥, che √® il numero di oggetti richiesti dallo stack [http://it.wikipedia.org/wiki/Stack] per una data operazione.
Sequenze arbitrariamente lunghe sono tipicamente denotate con una lettera minuscola in grassetto, ad es. o verr√† utilizzata per la sequenza di byte restituita come output di un messaggio di chiamata. Per valori particolarmente importanti, la lettera sar√† maiuscola.
Nel presente lavoro, si assume che gli scalari siano interi positivi e quindi che appartengano all‚Äôinsieme ‚Ñô. L‚Äôinsieme di tutte le sequenze di byte √® ùîπ, formalmente definita nell‚ÄôAppendice B. Se un tale insieme di sequenze √® limitato a quelle di una certa lunghezza, ci√≤ viene denotato con un opportuno pedice, cosicch√© tutte le sequenze di byte di lunghezza 32 sono chiamate ùîπ32, e l‚Äôinsieme di tutti gli interi positivi minori di 2256 √® chiamato ‚Ñô256. Una definizione formale viene fornita nella sezione 4.3.
Le parentesi quadre sono usate per indicizzare e fornire un riferimento a componeneit individuali o sottosequenze di sequenze, ad esempio, Œºs[0] denoter√† il primo oggetto della stack di una macchina. Per le sottosequenze, vengono utilizzate delle ellissi per specificare il range desiderato, includendo i limiti estremi, per cui Œºm[0..31] denoter√† i primi32 oggetti memorizzati nella macchina.
In caso di uno stato globale œÉ, che costituisce una sequenza di accounts, a loro volta tuple, le parentesi quadre vengono utilizzate per specificare un account individuale.
Quando vengono considerate varianti di valori esistenti, vale la convenzione per cui, all‚Äôinterno dell‚Äôambito riconosciuto per definizione, se assumiamo che il valore di ‚Äòinput‚Äô, non modificato, sia indicato dalla variabile metasintattica BOH, allora il valore modificato ed utilizzabile, sar√† di conseguenza denotato come BOH‚Äô, ed i valori intermedi come BOH*, BOH**, eccetera. In situazioni eccezionali, al fine di migliorare la leggibilit√† e solo in assenza di ambiguit√† sul significato, saranno utilizzati pedici alfanumerici per i valori intermedi, specialmente quelli di particolare importanza.
Nell‚Äôuso di funzioni esistenti, data una funzione f, f* denoter√† una versione ad essa simile negli elementi della struttura funzionale, piuttosto che per quanto concerne le sequenze. Questo verr√† formalmente definito nella sezione 4.3.
Una serie di funzioni utili verranno definite a mano a mano. Una tra le pi√π comuni √® ‚Ñì, che valuta fino all‚Äôultimo elemento la sequenza data da:
(5)	‚Ñì(x) ‚â° x [||x|| ‚Äì 1]

IV.	Blocchi, Stati e Transazioni

Dopo aver introdotto i concetti di base dietro Ethereum, discutiamo il significato delle transazioni, dei blocchi e degli stati in maggior dettaglio.

IV.I Stato del mondo. Lo stato del mondo (stato), √® una funzione di mappatura tra indirizzi (identificatori a 160 bit) e stati dei conti (una struttura di dati serializzata come RLP, v. Appendice B). Sebbene non inclusa nella blockchain, si assume che l‚Äôimplementazione gestir√† tale funzione di mappatura in un Merkle-Patricia tree modificato (trie, v. Appendice D) [https://github.com/ethereum/wiki/wiki/Patricia-Tree]. Il trie richiede un semplice back end [http://it.wikipedia.org/wiki/Front-end_e_back-end] di un database che mantenga una mappatura dei bytearrays [http://en.wikipedia.org/wiki/Bit_array]; questo database sottostante prende il nome di database di stato. Esso possiede una serie di benefici; in prima istanza il root node [http://en.wikipedia.org/wiki/Tree_%28data_structure%29 e http://en.wikipedia.org/wiki/Merkle_tree] di questa struttura √® crittograficamente dipendente da tutti i dati interni e di conseguenza il suo hash pu√≤ essere utilizzato come identit√† sicura per l‚Äôintero stato del sistema. Inoltre, essendo una struttura di dati immutabile, consente ad un qualsiasi stato precedente (di cui sia noto il root hash) di essere richiamato con una semplice alterazione del root hash. Poich√© tutti i root hash della blockchain vengono immagazzinati, tutti gli stati passati sono banalmente revertibili.
Lo stato dell‚Äôaccount comprende i seguenti quattro campi:
Nonce: un valore scalare equivalente al numero di transazioni inviate da questo indirizzo o, nel caso di conti con codice associato, il numero di contratti creati da questo account. Per l‚Äôindirizzo del‚Äôaccount a nello stato œÉ, la notazione √® œÉ[a]n. 
Bilancio: un valore scalare pari al numero di Wei posseduti da questo indirizzo. Notazione: œÉ[a]b.
storageRoot: un hash a 256 bit presente nel root node di un Merkle Patricia tree, che codifica i contenuti presenti nello spazio di archiviazione dell‚Äôaccount (una funzione di mappatura tra valori interi a 256 bit), codificato all‚Äôinterno del trie come mapping (dall‚Äôhash Keccak a 256 bit) delle chiavi a numeri interi a 256 bit verso i valori interi RLP-codificati a 256 bit. Tale hash √® formalmente denotato da œÉ[a]s.
codeHash: l‚Äôhash del codice EVM riferito a questo account ‚Äì questo √® il codice che viene eseguito nel caso in cui questo indirizzo ricevesse un messaggio; rimane immutabile e dunque, a differenza di ogni altro campo, non pu√≤ essere modificato dopo la sua costituzione.Ognuno di questi frammenti di codice sono contenuti nel database di stato, sotto gli hash corrispondenti, per poter essere recuperabili in futuro. Questo hash viene denotato formalmente da œÉ[a]c, per cui il codice sar√† chiamato b, dato che KEC(b) = œÉ[a]c.  

Poich√© √® preferibile evitare di riferirsi al root hash del trie, quanto piuttosto all‚Äôinsieme di coppie chiavi/valori sottostanti, immagazzinate al suo interno, √® possibile fornire questa utile equivalenza:
(6)	TRIE(L*I(œÉ[a]s)) ‚â° œÉ[a]s
La funzione di collasso per l‚Äôinsieme delle coppie chiavi/valori nel trie, L*I, √® definita come una trasformazione della funzione di base LI, data da:
(7)	LI((k,v)) ‚â° (KEC(k), RLP(v))
Dove
(8)	k ‚àä ùîπ32 ‚àß v ‚àä ‚Ñô
